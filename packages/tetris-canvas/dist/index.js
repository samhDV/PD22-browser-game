/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (() => {

eval("\nconst canvas = document.getElementById(\"game\");\nconst ctx = canvas.getContext(\"2d\");\nconst grid = 20;\nconst maxX = canvas.width / grid;\nconst maxY = canvas.height / grid;\nconst colors = {\n    I: \"#34B233\",\n    O: \"#A6ABB1\",\n    T: \"#6E2CB5\",\n    S: \"#C70099\",\n    Z: \"#00B2A9\",\n    J: \"#F2994A\",\n    L: \"#131787\",\n};\nconst tetrominos = {\n    I: [\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n    ],\n    J: [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n    ],\n    L: [\n        [0, 0, 1],\n        [1, 1, 1],\n        [0, 0, 0],\n    ],\n    O: [\n        [1, 1],\n        [1, 1],\n    ],\n    S: [\n        [0, 1, 1],\n        [1, 1, 0],\n        [0, 0, 0],\n    ],\n    Z: [\n        [1, 1, 0],\n        [0, 1, 1],\n        [0, 0, 0],\n    ],\n    T: [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n    ],\n};\nlet playfield = [];\n// populate the empty state\nfor (let row = 0; row < maxY; row++) {\n    playfield[row] = [];\n    for (let col = 0; col < maxX; col++) {\n        playfield[row][col] = 0;\n    }\n}\nfunction draw(matrix, x, y, color) {\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (matrix[row][col]) {\n                // drawing 1 px smaller than the grid creates a grid effect\n                ctx.fillStyle = color;\n                ctx.fillRect((x + col) * grid, (y + row) * grid, grid - 1, grid - 1);\n            }\n        }\n    }\n}\nfunction rotateMatrix(matrix) {\n    const N = matrix.length - 1;\n    return matrix.map((row, x) => row.map((el, y) => matrix[N - y][x]));\n}\nfunction getNextTetromino() {\n    const keys = Object.keys(tetrominos);\n    const randomKey = keys[Math.floor(Math.random() * keys.length)];\n    return {\n        name: randomKey,\n        matrix: tetrominos[randomKey],\n        x: 0,\n        y: 0,\n    };\n}\nlet tetromino = getNextTetromino();\ndocument.addEventListener(\"keydown\", function (e) {\n    // left and right arrow keys (move)\n    if (e.which === 37) {\n        tetromino = goLeft(tetromino);\n    }\n    if (e.which === 39) {\n        tetromino = goRight(tetromino);\n    }\n    // up arrow key (rotate)\n    if (e.which === 38) {\n        tetromino = rotate(tetromino);\n    }\n    // down arrow key (drop)\n    if (e.which === 40) {\n        tetromino = goDown(tetromino);\n    }\n    // d for 'drop in place'\n    if (e.which === 68) {\n        tetromino = placeTetromino(tetromino);\n    }\n    // space\n    if (e.which === 32) {\n        paused = !paused;\n    }\n});\nfunction goDown(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { y: tetromino.y + 1 });\n    return isValid(newState) ? newState : tetromino;\n}\nfunction canGoDown(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { y: tetromino.y + 1 });\n    return isValid(newState);\n}\nfunction goLeft(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { x: tetromino.x - 1 });\n    return isValid(newState) ? newState : tetromino;\n}\nfunction goRight(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { x: tetromino.x + 1 });\n    return isValid(newState) ? newState : tetromino;\n}\nfunction goUp(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { y: tetromino.y - 1 });\n    return isValid(newState) ? newState : tetromino;\n}\nfunction rotate(tetromino) {\n    const newState = Object.assign(Object.assign({}, tetromino), { matrix: rotateMatrix(tetromino.matrix) });\n    return isValid(newState) ? newState : tetromino;\n}\nfunction placeTetromino(tetromino) {\n    for (let row = 0; row < tetromino.matrix.length; row++) {\n        for (let col = 0; col < tetromino.matrix[row].length; col++) {\n            if (tetromino.matrix[row][col]) {\n                playfield[tetromino.y + row][tetromino.x + col] = tetromino.name;\n            }\n        }\n    }\n    verifyPlayfield(playfield);\n    return getNextTetromino();\n}\nfunction verifyPlayfield(playfield) {\n    for (let row = playfield.length - 1; row >= 0;) {\n        if (playfield[row].every((cell) => !!cell)) {\n            // drop every row above this one\n            for (let r = row; r >= 0; r--) {\n                for (let c = 0; c < playfield[r].length; c++) {\n                    const val = r > 0 ? playfield[r - 1][c] : 0;\n                    playfield[r][c] = val;\n                }\n            }\n        }\n        else {\n            row--;\n        }\n    }\n}\nlet counter = 0;\nlet paused = false;\nfunction loop() {\n    if (paused) {\n        return;\n    }\n    counter++;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // draw playfield\n    for (let row = 0; row < maxY; row++) {\n        for (let col = 0; col < maxX; col++) {\n            if (playfield[row][col]) {\n                const name = playfield[row][col];\n                ctx.fillStyle = colors[name];\n            }\n            else {\n                ctx.fillStyle = \"white\";\n            }\n            ctx.fillRect(col * grid, row * grid, grid - 1, grid - 1);\n        }\n    }\n    if (counter === 30) {\n        counter = 0;\n        if (!canGoDown(tetromino)) {\n            tetromino = placeTetromino(tetromino);\n        }\n        else {\n            tetromino = goDown(tetromino);\n        }\n    }\n    draw(tetromino.matrix, tetromino.x, tetromino.y, colors[tetromino.name]);\n}\nsetInterval(loop, 10);\nfunction isValid(tetromino) {\n    return isValidMove(tetromino.matrix, tetromino.x, tetromino.y);\n}\nfunction isValidMove(matrix, cellCol, cellRow) {\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (matrix[row][col] &&\n                // outside the game bounds\n                (cellCol + col < 0 ||\n                    cellRow + row < 0 ||\n                    cellCol + col >= maxX ||\n                    cellRow + row >= maxY ||\n                    playfield[cellRow + row][cellCol + col])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://tetris-canvas/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;